## OSI七层模型模型

开放式系统互联模型（**O**pen **S**ystem **I**nterconnection Model）

![](https://qwq.lsaiah.cn/usr/uploads/Picture/OSI.png)

## TCP/IP五层模型

由于TCP/IP的会话层较弱，并且通过不同应用的不同端口打开和关闭连接，通常将OSI模型最上面的三层（应用层、表示层、会话层）在TCP/IP协议中组成一个应用层。

### 一. 物理层

物理层负责管理电脑通信设备和网络媒体之间的互通，通过光缆、电缆、无线电等物理手段将电脑连接起来，负责传送0和1的电信号。

### 二. 数据链路层

数据链路层确定了0和1的分组方式，通过数据包的MAC地址发送广播传输数据。其中以太网协议占大多数，它规定将一组电信号组成一个数据包叫做帧（Data Frame），分成标头和数据两部分。标头包含数据包的一些说明，比如发送者、接收者网卡的MAC地址、数据类型等，数据则是数据包的具体内容。发送者通过ARP协议发送广播到同一个网络，接收者获取接受方的MAC地址与自身MAC地址比较，如果相同则接收，不同则丢弃这个数据包。

### 三. 网络层

接受方通过MAC地址识别数据包的效率低且局限于同一个子网络，于是通过网络层的路由引入一套新的网络地址来确定计算机所在的子网络。其中网络地址的协议叫做IP协议，IP地址表示子网络和主机，通过子网掩码表示子网络。通过IP协议发送的数据包是放在以太网数据包里发送的，标头部分主要包含以太网的标头和版本、长度、IP地址等信息，数据部分则是具体内容。当两台主机不在同一个网络时需要通过子网络的网关处理，当在同一个网络时通过ARP协议和IP协议发送IP地址，子网络的接收者获取IP地址与自身IP比较，相同时则接收并发送MAC地址，否则丢弃数据包。

### 四. 传输层

有了MAC地址和IP地址就可以进行网络通信，但主机上有许多程序都需要网络，如何区分不同数据包？需要引入传输层的端口建立端到端的网络通信，Unix系统把主机+端口叫做套接字（socket），通过socket就可以实现不同网络程序分发不同数据包。在数据包上加入端口信息需要新的协议，其中最简单的协议是UDP协议，它的标头部分主要定义了发出端口和接收端口，数据部分是具体的内容。然后将UDP数据包放入IP数据包中，所以整个数据包包含以太网数据包、IP数据包、UDP数据包。它的优点是简单容易实现，缺点是可靠性差，一旦发出无法确认对方是否收到。为了提高可靠性，诞生了TCP协议，每发出一个数据包都要求确认，确保数据不会遗失，缺点是过程复杂三次握手，四次挥手、实现困难、消耗资源多。TCP和UDP的数据包一样都是放在IP数据包的数据部分。

### 五. 应用层

通过传输层接收到指定主机和指定程序的数据包时，通过应用层规定程序的数据包格式进行解读，以实现应用软件之间的通信。如TCP协议传递的数据通过HTTP、FTP、SMTP等应用层协议解读为不同应用的通信。它的数据放在TCP数据包的数据部分，标头包含以太网标头、IP标头、TCP标头。

## TCP协议

传输控制协议（**T**ransmission **C**ontrol **P**rotocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议通过socket套接字实现了网络通信和数据交换。

### 三次握手

![](https://qwq.lsaiah.cn/usr/uploads/Picture/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png)

TCP通过三次握手建立连接：

1. 客户端发送SYN（SEQ=0）报文给服务器端，进入SYN_SEND状态。
2. 服务器端收到SYN报文，回应一个SYN（SEQ=0）+ACK（ACK=1）报文，进入SYN_RECV状态。
3. 客户端收到服务器端的SYN+ACK报文，回应一个ACK（SEQ=1, ACK=1）报文，进入Established建立连接状态。

### 四次挥手

![](https://qwq.lsaiah.cn/usr/uploads/Picture/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png)

TCP通过四次挥手断开连接：

1. 首先执行close()方法，表示该端执行主动关闭并通过TCP发送一个FIN=1的包，表示不再发送但可接收数据，进入`FIN_WAIT_1`状态。
2. 接收到这个FIN的包后会发送一个确认包ACK，表示已经收到关闭请求但没有准备好关闭连接。发送完毕后进入`CLOSE_WAIT`状态，对端进入`FIN_WAIT_2`状态等待关闭。
3. 等到服务端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。

   发送完毕后，服务器端进入 `LAST_ACK` 状态，等待来自客户端的最后一个ACK。
4. 客户端接收到来自服务器端的关闭请求发送一个确认包，并进入 `TIME_WAIT`状态，等待可能出现的要求重传的 ACK 包。服务器端接收到这个确认包之后，关闭连接，进入 `CLOSED` 状态。客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 `CLOSED` 状态。