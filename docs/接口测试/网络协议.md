## OSI七层模型模型

开放式系统互联模型（**O**pen **S**ystem **I**nterconnection Model）

![](https://qwq.lsaiah.cn/usr/uploads/Picture/OSI.png)

![img](https://qwq.lsaiah.cn/picgo/20210310100043.png)

## TCP/IP五层模型

由于TCP/IP的会话层较弱，并且通过不同应用的不同端口打开和关闭连接，通常将OSI模型最上面的三层（应用层、表示层、会话层）在TCP/IP协议中组成一个应用层。

### 一. 物理层

物理层负责管理电脑通信设备和网络媒体之间的互通，通过光缆、电缆、无线电等物理手段将电脑连接起来，负责传送0和1的电信号。

### 二. 数据链路层

数据链路层确定了0和1的分组方式，通过数据包的MAC地址发送广播传输数据。其中以太网协议占大多数，它规定将一组电信号组成一个数据包叫做帧（Data Frame），分成标头和数据两部分。标头包含数据包的一些说明，比如发送者、接收者网卡的MAC地址、数据类型等，数据则是数据包的具体内容。发送者通过ARP协议发送广播到同一个网络，接收者获取接受方的MAC地址与自身MAC地址比较，如果相同则接收，不同则丢弃这个数据包。

### 三. 网络层

接受方通过MAC地址识别数据包的效率低且局限于同一个子网络，于是通过网络层的路由引入一套新的网络地址来确定计算机所在的子网络。其中网络地址的协议叫做IP协议，IP地址表示子网络和主机，通过子网掩码表示子网络。通过IP协议发送的数据包是放在以太网数据包里发送的，标头部分主要包含以太网的标头和版本、长度、IP地址等信息，数据部分则是具体内容。当两台主机不在同一个网络时需要通过子网络的网关处理，当在同一个网络时通过ARP协议和IP协议发送IP地址，子网络的接收者获取IP地址与自身IP比较，相同时则接收并发送MAC地址，否则丢弃数据包。

### 四. 传输层

有了MAC地址和IP地址就可以进行网络通信，但主机上有许多程序都需要网络，如何区分不同数据包？需要引入传输层的端口建立端到端的网络通信，Unix系统把主机+端口叫做套接字（socket），通过socket就可以实现不同网络程序分发不同数据包。在数据包上加入端口信息需要新的协议，其中最简单的协议是UDP协议，它的标头部分主要定义了发出端口和接收端口，数据部分是具体的内容。然后将UDP数据包放入IP数据包中，所以整个数据包包含以太网数据包、IP数据包、UDP数据包。它的优点是简单容易实现，缺点是可靠性差，一旦发出无法确认对方是否收到。为了提高可靠性，诞生了TCP协议，每发出一个数据包都要求确认，确保数据不会遗失，缺点是过程复杂三次握手，四次挥手、实现困难、消耗资源多。TCP和UDP的数据包一样都是放在IP数据包的数据部分。

### 五. 应用层

通过传输层接收到指定主机和指定程序的数据包时，通过应用层规定程序的数据包格式进行解读，以实现应用软件之间的通信。如TCP协议传递的数据通过HTTP、FTP、SMTP等应用层协议解读为不同应用的通信。它的数据放在TCP数据包的数据部分，标头包含以太网标头、IP标头、TCP标头。

## TCP协议

传输控制协议（**T**ransmission **C**ontrol **P**rotocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议通过socket套接字实现了网络通信和数据交换。

### 三次握手

![](https://qwq.lsaiah.cn/usr/uploads/Picture/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png)

TCP通过三次握手建立连接：

1. 客户端发送SYN = 1（SEQ = x）报文给服务器端，进入SYN_SEND状态。
2. 服务器端收到SYN报文，回应一个SYN = 1和一个ACK = x + 1，SEQ = Y报文，进入SYN_RECV状态。
3. 客户端收到服务器端的SYN+ACK报文，SEQ = Y，回应一个ACK = Y + 1报文，SEQ = Z 进入Established建立连接状态。

### 四次挥手

![](https://qwq.lsaiah.cn/usr/uploads/Picture/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png)

TCP通过四次挥手断开连接：

1. 首先执行close()方法，表示该端执行主动关闭并通过TCP发送一个FIN=1的包，SEQ = u 表示不再发送但可接收数据，进入`FIN_WAIT_1`状态。

2. 接收到这个FIN的包后会发送一个确认包ACK = 1，SEQ = V，ackNum = u + 1表示已经收到关闭请求但没有准备好关闭连接。发送完毕后进入`CLOSE_WAIT`状态，对端进入`FIN_WAIT_2`状态等待关闭。

3. 等到服务端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1，ACK = 1, SEQ = W， ackNum = u+1

   发送完毕后，服务器端进入 `LAST_ACK` 状态，等待来自客户端的最后一个ACK。
   
4. 客户端接收到来自服务器端的关闭请求发送一个确认包，并进入 `TIME_WAIT`状态，等待可能出现的要求重传的 ACK 包。服务器端接收到这个确认包之后ACK = 1, SEQ = U+1, ackNum = w + 1，关闭连接，进入 `CLOSED` 状态。客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 `CLOSED` 状态。

## HTTP

HTTP/1.1

-  持久连接。TCP三次握手会在任何连接被建立之前发生一次。最终，当发送了所有数据之后，服务器发送一个消息，表示不会再有更多数据向客户端发送了；则客户端才会关闭连接（断开 TCP）
-  支持的方法: `GET` , `HEAD` , `POST` , `PUT` ,`DELETE` , `TRACE` , `OPTIONS`
-  进行了重大的性能优化和特性增强，分块传输、压缩/解压、内容缓存磋商、虚拟主机（有单个IP地址的主机具有多个域名）、更快的响应，以及通过增加缓存节省了更多的带宽

HTTP2

-  所有数据以二进制传输。HTTP1.x是基于文本的，无法保证健壮性，HTTP2.0绝对使用新的二进制格式，方便且健壮
-  同一个连接里面发送多个请求不再需要按照顺序来
-  头信息压缩以及推送等提高效率的功能

HTTP3

-  QUIC“快速UDP互联网连接”（Quick UDP Internet Connections）

HTTP3 的主要改进在传输层上。传输层不会再有我前面提到的那些繁重的 TCP 连接了。现在，一切都会走 UDP。

### HTTP报文

请求报文：

![img](https://qwq.lsaiah.cn/picgo/20210310101357.png)

响应报文：

![](https://qwq.lsaiah.cn/picgo/20210310101445.png)

### HTTPS

在HTTP的基础上再加一层TLS（传输层安全性协议）或者SSL（安全套接层），就构成了HTTPS协议。

HTTPS 默认工作在 TCP 协议443端口，它的工作流程一般如以下方式：

1. TCP 三次同步握手
2. 客户端验证服务器数字证书
3. DH 算法协商对称加密算法的密钥、hash 算法的密钥
4. SSL 安全加密隧道协商完成
5. 网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的hash算法进行数据完整性保护，保证数据不被篡改。

HTTPS连接 需要7次握手，3次TCP + 4次TSL。

![](https://qwq.lsaiah.cn/picgo/20210310101826.png)

1. 客户端向服务端发送 `Client Hello` 消息，其中携带客户端支持的协议版本、加密算法、压缩算法以及客户端生成的随机数；
2. 服务端收到客户端支持的协议版本、加密算法等信息后；
   1. 向客户端发送 `Server Hello` 消息，并携带选择特定的协议版本、加密方法、会话 ID 以及服务端生成的随机数；
   2. 向客户端发送 `Certificate` 消息，即服务端的证书链，其中包含证书支持的域名、发行方和有效期等信息；
   3. 向客户端发送 `Server Key Exchange` 消息，传递公钥以及签名等信息；
   4. 向客户端发送可选的消息 `Certificate Request`，验证客户端的证书；
   5. 向客户端发送 `Server Hello Done` 消息，通知服务端已经发送了全部的相关信息；
3. 客户端收到服务端的协议版本、加密方法、会话 ID 以及证书等信息后，验证服务端的证书；
   1. 向服务端发送 `Client Key Exchange` 消息，包含使用服务端公钥加密后的随机字符串，即预主密钥（`Pre Master Secret`）；
   2. 向服务端发送 `Change Cipher Spec` 消息，通知服务端后面的数据段会加密传输；
   3. 向服务端发送 `Finished` 消息，其中包含加密后的握手信息；
4. 服务端收到 `Change Cipher Spec`和`Finished`消息后；
   1. 向客户端发送 `Change Cipher Spec` 消息，通知客户端后面的数据段会加密传输；
   2. 向客户端发送 `Finished` 消息，验证客户端的 `Finished` 消息并完成 TLS 握手；

TLS 握手的关键在于利用通信双发生成的随机字符串和服务端的证书公钥生成一个双方经过协商后的对称密钥，这样通信双方就可以使用这个对称密钥在后续的数据传输中加密消息数据，防止中间人的监听和攻击，保证通讯安全。